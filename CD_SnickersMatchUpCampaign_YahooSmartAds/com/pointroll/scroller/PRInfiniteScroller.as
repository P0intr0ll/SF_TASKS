package com.pointroll.scroller{	import com.pointroll.interfaces.IScroller;	import flash.display.MovieClip;	import com.greensock.TweenNano;		import flash.events.Event;	import flash.events.EventDispatcher;		import flash.display.Sprite;		import flash.utils.Timer;	import flash.events.TimerEvent;		import com.pointroll.events.PRScrollerEvents;	public class PRInfiniteScroller extends EventDispatcher implements IScroller{		private var _totalItems:int;		private var _currentPage:int;		private var _totalPages:int;		private var _howManyToDisplay:int;		private var _autoScrollItems:int;		private var _maskMc:Sprite;		private var _holder:MovieClip;		private var _itemWidth:Number;		private var _distance:Number;		private var _startX:Number;		private var _duration:Number;		private var _padding:Number;		private var _canScroll:Boolean;		private var _infinite:Boolean;				private var _items:Array;				private var _timer:Timer;				private var _dataObject:Object;		public function PRInfiniteScroller(items:Array, h:MovieClip, m:Sprite, numberOfItems:int, howManyProductsToDisplay:int=1) {			_items = items;			_holder = h;			_maskMc = m;			_totalItems = numberOfItems;			_howManyToDisplay = howManyProductsToDisplay;			_totalPages = Math.ceil((_totalItems / _howManyToDisplay));			_itemWidth = _items[0].width;			_currentPage = 1;			_distance = _itemWidth * _howManyToDisplay;			_canScroll = true;			_dataObject = new Object();			_duration = .5;			_padding =0;						buildScroller();		}		public function buildScroller():void {			_holder.mask = _maskMc;			_holder.x = _maskMc.x;			_holder.y = _maskMc.y;			_itemWidth = _items[0].width + _padding;			_distance = _itemWidth * _howManyToDisplay;		}			private function shiftItem():void {			var _clip:Sprite = _items.shift();			_clip.x = _items[_items.length-1].x + _distance			_items.push(_clip);		}		private function popItem():void {			var _clip:Sprite = _items.pop();			_clip.x = _items[0].x - _distance			_items.unshift(_clip);		}		public function autoScroll(duration:Number, howManyItems:int):void{			_autoScrollItems = howManyItems;			_timer = new Timer(duration, _autoScrollItems );			_timer.addEventListener(TimerEvent.TIMER, onTimerEvent);			_timer.start();		}		public function reset(numberOfItems:int,howManyProductsToDisplay:int):void{			_totalItems = numberOfItems;			_howManyToDisplay = howManyProductsToDisplay;			_totalPages = Math.ceil((_totalItems / _howManyToDisplay));			_itemWidth = _holder.width / _totalItems;			_currentPage = 1;			_distance = _itemWidth * _howManyToDisplay;			_canScroll = true;			_startX = _holder.x			buildScroller();		}		public function previousItem():void {						if (_canScroll) {				_canScroll = false;				if (_currentPage != 1) {										_currentPage--;										_dataObject.currentPage = _currentPage;												}else{					popItem();				}					dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_PREVIOUS_ITEM, _dataObject));						//trace("previousItem: " + (_distance+_holder.x) +					//  " _currentPage: " + _currentPage + " _totalPages: " + _totalPages);				TweenNano.to(_holder,_duration,{x:(_distance+_holder.x),onComplete:onScrollerTweening});					}		}		public function nextItem():void {				if (_canScroll) {					_canScroll = false;				if (_currentPage != _totalPages) {														_currentPage++;													 	_dataObject.currentPage = _currentPage;												}else{										shiftItem();				}				dispatchEvent(new PRScrollerEvents(PRScrollerEvents.ON_NEXT_ITEM, _dataObject));				//trace("nextItem: " + (_distance-_holder.x)+					//   " _currentPage: " + _currentPage + " _totalPages: " + _totalPages);				TweenNano.to(_holder,_duration,{x:(_holder.x-_distance),onComplete:onScrollerTweening});				}					}		public function killAutoTimer():void{			if(_timer){				_timer.stop();				_timer.removeEventListener(TimerEvent.TIMER, onTimerEvent);				_timer = null;			}		}				//EVENTS		private function onScrollerTweening():void {			_canScroll = true;		}		private function onTimerEvent(e:TimerEvent):void{			if(_timer.currentCount == _autoScrollItems){				killAutoTimer()			}else{				nextItem();			}					}				// GETTERS SETTERS		public function get currentPage():int{			return _currentPage;		}				public function get item():Array{			return _items;		}		public function set duration(d:Number):void{			_duration = d;		}		public function set padding(p:Number):void{			_padding = p;		}		public function set currentPage(n:int):void{			_currentPage = n;		}		public function set item(a:Array):void{			_items = a;		}	}}