package com.PointRoll.Widgets{		import flash.text.*;	import flash.text.TextFormat;	import flash.text.TextFieldAutoSize;		import com.PointRoll.Widgets.Debug;		public class StringUtils	{				private static var tfWidthOrig:Number;		private static var tfHeightOrig:Number;				public function StringUtils()		{		}						public static function fitTextInBox(WorH:String,txtField:TextField,txtFormat:TextFormat,txtSize:Number,txtWH:Number,txt:String, _numLines:Number = 2) {			if (WorH=="w") {				//trace("\n txtField.textWidth: " + txtField.textWidth)								while (txtField.textWidth > txtWH || txtField.numLines > _numLines) { 					trace("is txtField.numLines "+txtField.numLines +" > _numLines"+ _numLines); 					//trace("fitTextInBox: textWidth "+txtField.textWidth); 					//trace("fitTextInBox: width "+txtField.width);					txtSize -= 1;					//trace("\n txtSize: " + txtSize); 					txtFormat.size=txtSize;  					txtField.antiAliasType=AntiAliasType.ADVANCED; 					txtField.defaultTextFormat=txtFormat;					txtField.text = txt;										//reposition the ypos as text shrinks					//txtField.y += 1; 				}				//trace("fitTextInBox:  txtField textWidth "+txtField.textWidth);							} else { 				while (txtField.textHeight > txtWH || txtField.numLines > _numLines) {					 					//trace("fitTextInBox txtWH "+txtWH );					txtSize-=1;					//trace("txtFormat.size "+txtSize);					txtFormat.size=txtSize;					//txtFormat.align="left";					txtField.antiAliasType=AntiAliasType.ADVANCED;					txtField.defaultTextFormat=txtFormat;					txtField.text = txt;					//trace("fitTextInBox textHeight "+txtField.textHeight); 				} 							}}				 		public static function sizeTFtoText(tf:TextField, str:String, useHTML:Boolean = false, startSize:Number = 14, minHeight:Number = 8, useElipses:Boolean = false, txtW:Number = 0, txtH:Number = 0, numLines:Number = 4):Number		{			var tfFormat:TextFormat = tf.getTextFormat();			var maxLines:Number = numLines;									if (txtW != 0)			{				tfWidthOrig = txtW;			}			else			{				tfWidthOrig = tf.width;			}			if (txtH != 0)			{				tfHeightOrig = txtH;			}			else			{				tfHeightOrig = tf.height;			}						var scalePercent:Number = 1;			//tf.autoSize = TextFieldAutoSize.CENTER;						if (useHTML)			{				tf.htmlText = str;				var tmpArr:Array = str.split("<br>");				maxLines = tmpArr.length;			}			else			{				tf.text = str;			}						var newFormat:TextFormat = new TextFormat();			tfFormat.size = startSize;			//tfFormat.leading = 4; 			var iterator:Number = 0;			var iterator2:Number = 0;			 			trace(">tf.textHeight: "+tf.textHeight+"  >= tfHeightOrig:"+tfHeightOrig );			var success:Boolean = true;			while ((tf.textHeight >= tfHeightOrig) && (tf.numLines > maxLines))			{				Debug.it("****HEIGHT RESIZING****the str: " + str + ", Number of Lines = "+tf.numLines+", maxLines = "+maxLines);				scalePercent = tfHeightOrig / tf.textHeight;				//trace(">tf.textHeight: "+tf.textHeight+"  >= tfHeightOrig:"+tfHeightOrig );				if (iterator++ % 2)				{					//trace(" minHeight: " + minHeight)					//trace(" tfFormat.size: " + tfFormat.size)					if (minHeight <= (Number(tfFormat.size) * tf.numLines))					{						tfFormat.size = Number(tfFormat.size) - 1;					}					else					{						success = false;						break;					}				}				else				{					//tfFormat.leading = Number(tfFormat.leading) - 1;				}				tf.setTextFormat(tfFormat);			}			//trace("\n tf.textWidth: " + tf.textWidth)			//trace("\n tfWidthOrig: " + tfWidthOrig)			if (tf.textWidth > tfWidthOrig) 			{				while ((tf.textWidth >= tfWidthOrig) || (tf.numLines > maxLines))				{					//Debug.it(" ****WIDTH RESIZING**** the str: " + str + ", Number of Lines = "+tf.numLines+", maxLines = "+maxLines);					scalePercent = tfWidthOrig / tf.textWidth;					//trace("> "+tfFormat.size+" - "+tf.textHeight+" ?> "+tfHeightOrig);					if (iterator2++ % 2)					{						//if (minHeight <= (Number(tfFormat.size) - 1))						//{							tfFormat.size = Number(tfFormat.size) - 1;						//}						//else						//{							//success = false;							//break;						//}					}					else					{						tfFormat.leading = Number(tfFormat.leading) - 1;					}					tf.setTextFormat(tfFormat);				}			}												if (!success && useElipses)			{				//Debug.it("Using Elipses for text:"+tf.text);				while (tf.textHeight >= tfHeightOrig)				{					tf.text = tf.text.slice(0, tf.text.lastIndexOf(" ")) + "…";					tf.setTextFormat(tfFormat);				}				//Debug.it("Final Text = "+tf.text);				scalePercent = tfHeightOrig / tf.textHeight;			}			//Debug.it("Final number of Lines = " + tf.numLines + ", maxLines = " + maxLines + ", size = " + tfFormat.size + ", height = " + tf.textHeight + " should be < " + tfHeightOrig);			return scalePercent;		}	}}